# 테스트

### 통합 테스트의 문제점
에러가 발생했을 때 호출 스택만으로 에러의 원인을 파악하기가 힘들다. 

### Unit Test (단위 테스트)
> 테스트는 가능하면 작은 단위로 쪼개서 집중해서 해야 한다.

확인의 대상과 조건을 간단하고 명확하게 하여 의도대로 동작하는지 확인한다.  

### 자동수행 테스트
> 테스트 값 입력까지 자동화하여 결과를 본다면 짧은 시간에 테스트가 가능하다.

### 지속적이고 점진적인 개발을 위한 테스트
단위 테스트를 기반으로 정상 동작하는 것에 대한 확신을 갖고 전체적으로 코드를 개선해 나간다.

### 테스트 내용
> - 조건 (Given)   
> 어떤 조건을 가지고
> - 행위 (When)   
> 무엇을 할 때
> - 결과 (Then)   
> 어떤 결과가 나온다

### 테스트 조건
1. 테스트는 일관적이어야 한다. 테스트 순서나 중복실행과 상관없이 일관적으로 결과가 나오도록 만들어야 한다.
2. 테스트는 포괄적이어야 한다. 나올 수 있는 결과를 모두 검사하는 테스트를 작성하자.
    - 실패하는 테스트도 작성해야 한다.


### TDD
> 테스트를 먼저 만들고 성공하게 해주는 코드를 만드는 방식

테스트를 작성하고 코드를 만드는 작업의 주기를 짧게 하여 자주 피드백을 받게 한다. 

테스트를 먼저 만드는 것이 불편하다면 코딩이 끝나자마자 빠른 시간 안에 테스트코드를 만들자.

## 스프링에서의 테스트

### 애플리케이션 컨텍스트 관리
스프링 테스트에서는 여러개의 클래스에서 애플리케이션 컨텍스트를 공유한다.

@Autowired 가 붙은 인스턴스 변수는 변수 타입과 일치하는 빈에서 주입받는다.

### DI
개발에서 절대 바뀌지 않을 것이라고 해도 인터페이스를 두고 DI를 적용해야 하는 이유
- 만약 바뀌게 되는 경우를 대비할 수 있다.
- 스프링의 기능을 활용하여 부가기능을 추가할 수 있다.
- 효율적인 테스트를 손쉽게 만들 수 있다.

### 테스트 코드에 의한 DI
운영용 DB와 다른 DB를 써야하는 경우, 테스트 코드에 의한 DI를 이용해서 테스트 중에 사용할 오브젝트를 바꿔준다.

이 방법은 Bean 설정을 강제로 변경하기 때문에 조심해서 사용해야 한다. 
따라서 @DirtiesContext 애너테이션을 붙여서 애플리케이션 컨텍스트 공유를 막는다. 메서드에도 사용이 가능하다.

단점 : 코드가 많아진다, 애플리케이션 컨텍스트를 매번 새로 만들어야 한다.

### 테스트를 위한 DI 설정
테스트에만 쓰일 DataSource 를 따로 만들어둔다. 그리고 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해 준다.
```java
@ContextConfiguration(locations="/test-applicationContext.xml")
```

### 컨테이너 없는 DI 테스트
@Autowired 없이, 컨테이너를 사용하지 않고, 직접 DI 해서 테스트 한다. 

이 경우 매번 새로운 오브젝트가 만들어진다.

### 버그테스트
실패하도록 만들어서 실패 원인을 해결하기 위한 테스트
 - 테스트의 완성도를 높여준다.
 - 버그의 내용을 명확하게 분석하게 해준다.
 - 기술적인 문제를 해결하는 데 도움이 된다.

> - 동등분할 (equivalence partitioning) : 범위를 구분해서 각 범위의 대표 값으로 테스트를 하는 방법
> - 경계값 분석 (boundary value analysis) : 경계의 근처에 있는 값을 이용해 테스트하는 방법