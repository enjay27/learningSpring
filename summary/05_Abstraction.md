# 추상화

### 다음과 같은 질문을 던져본다.
1. 코드에 중복된 부분은 없는가?
2. 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
3. 코드가 자신이 있어야 할 자리에 있는가?
4. 앞으로 변경이 일어난다면 변화에 쉽게 대응할 수 있는가?

> 코드의 실행을 추상화하여 공통점을 뽑아내고 코드의 중복을 없앤다.

> Service 레이어에 많은 정보를 담을 필요가 없다. enum을 선언하여 여기에 정보를 담는다.   
> 각 오브젝트와 메서드에 책임을 분리한다.

> 기본은 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청하는 것이다.


### 트랜잭션 테스트
AutoCommit 을 false 로 설정하여 트랜잭션을 조정한다.    
SQL 작업 결과에 따라 commit 과 rollback 을 호출한다.

Spring 에서는 TransactionSynchronizationManager 클래스를 이용해 트랜잭션을 관리한다.
```java
TransactionSynchronizationManager.initSynchronization();
Connection c = DataSourceUtils.getConnection(dataSource);
```
동기화 이후 DataSourceUtils 를 사용하여 Connection 생성 후 트랜잭션 동기화에 사용하도록 저장소에 바인딩한다.
```java
TransactionSynchronizationManager.unbindResource(this.dataSource);
TransactionSynchronizationManager.clearSynchronization();
```
다 끝났으면 Connection 을 닫고 동기화를 중단한다.


### 추상화로 문제해결
트랜잭션 처리 때문에 JDBC 클래스에 의존하는 코드가 됐다. 이 문제는 트랜잭션 처리 코드에 대한 추상화로 해결할 수 있다.    
스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공한다.
```java
PlatformTransactionManager transactionManager = 
        new DataSourceTransactionManager(dataSource);

TransactionStatus status = 
        transactionManager.getTransaction(new DefaultTransactionDefinition());
```

- PlatformTransactionManager : 스프링이 제공하는 추상 인터페이스
- DataSourceTransactionManager : JDBC의 로컬 트랜잭션을 위한 TransactionManager 구현체

이후 getTransaction 메서드를 호출하여 트랜잭션을 가져오고 작업을 수행한다.
```java
transactionManager.commit(status);
```
작업이 끝나면 커밋 혹은 롤백으로 트랜잭션을 마친다.

여기서 transactionManager 를 생성할때 구현 클래스에 의존하기 때문에 이 또한 빈으로 분리시키고 나면 의존이 사라지게 된다.   
빈으로 등록하기 전 검토해야 할 점은 __싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은가__ 하는 점이다.

빈으로 등록하고 나면 트랜잭션 기술에서 완전히 독립적인 코드가 된다. 이후 다른 트랜잭션 기술을 이용하게 된다면 Bean 설정만 바꾸면 된다.

### 단일 책임 원칙
인터페이스를 사이에 두고 스프링 DI를 사용하여 결합도를 낮춘다. 이는 계층구조가 어떻든 간에 관계없이 적용시킬 수 있다.

같은 계층이라면 각각 담당하는 코드의 기능을 분리하여 서로 불필요한 영향을 주지 않으면서 확장이 가능하도록 만든다.

다른 계층이라면 해당 기술을 사용하는 코드의 공통점을 뽑아 인터페이스를 만들어 스프링 DI를 사용한다.    
이에 대해서는 스프링이 제공하는 기술들에 대하여 잘 알고 있어야한다.

> 단일 책임이 아니라 두 가지 이상의 책임을 갖고 있다는 건 해당 클래스가 수정될 이유가 두 가지 이상이라는 점이다.

단일책임을 지키고 나면 어떤 변경이 필요해질 때 수정 대상이 명확해진다.

단일책임원칙을 지키는 코드를 만들고자 인터페이스를 도입 후 DI로 연결하고 나면 개방폐쇄원칙도 지켜진다.

좋은 코드를 설계하고 만들기 위한 노력이 필요하고 해당 코드를 어떻게 개선할 수 있는지 꾸준히 노력해야 한다.


### 더미 테스트
스프링에서 제공하는 추상 인터페이스를 이용하여 가짜 오브젝트를 만들고 DI 하여 테스트를 진행한다.    
이렇게 하면 테스트가 실제 운영에 영향을 주는 일이 없어진다.   
테스트가 완료 되면 Bean 설정을 바꿔 운영으로 돌린다.   
애플리케이션 계층에서는 mock object 의 메서드를 실행하는 로직만 신경쓰면 된다.

mock object 에도 트랜잭션 개념을 적용시키기 위한 방법은 두 가지다.
1. 해당 로직에 해당하는 대상을 별도의 목록에 저장한 후 한번에 처리하는 방법.
   - 저장용 리시트 등을 파라미터로 계속 갖고 다녀야 한다.
    
2. 트랜잭션 기능이 있는 구현 클래스를 만들어 사용하는 방법. 
   - 서로 다른 종류의 작업을 분리해 처리한다.
    
### 테스트를 위한 DI 설정
테스트를 위한 설정파일 및 환경을 따로 만들어 테스트한다.

DAO 테스트에서는 개발용 DB에 연결하여 동작하는 구현체를 DI 한다.   
Service 테스트에서는 메일발송 등 운영서버에서는 불가능한 테스트를 할 때 DummyObject 를 DI 한다.

이처럼 테스트 대상이 되는 오브젝트가 다른 오브젝트에 의존하고 있을 땐 empty object 를 만들어서 DI 해주는 게 큰 도움이 된다.

### 테스트 대역
 - 테스트 대역(test double) : 테스트의 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 테스트를 실행할 수 있도록 사용하는 오브젝트
 - 테스트 스텁(test stub) : 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것

테스트 스텁이 결과를 리턴해야 하는 경우도 있다. 이 경우 테스트 중에 필요한 정보를 리턴하도록 만들 수 있다.   
예외를 발생시키게 해서 테스트 대상 오브젝트의 예외 상황 대처를 테스트 할 때 적용할 수도 있다.


 - 가짜 객체(mock object) : 테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 설계된 오브젝트

테스트 대상과 의존 오브젝트 사이에 주고받는 정보를 보관해주는 기능을 가진 오브젝트를 만들어서 사용한다.

메일 발송 테스트의 경우 발송 대상을 mock object 에 저장하고 대상이 된 총 인원 수와 대상 메일을 확인한다.
