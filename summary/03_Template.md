# 템플릿

> 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법

### 분리와 재사용
변하는 부분과 변하지 않는 부분을 찾아 추출해낸다. 

> 템플릿 메서드 패턴 사용
> - 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메서드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 사용한다.   
> 
> 단점 : 새로운 메서드가 추가될 때마다 새로운 서브클래스가 추가된다.

> 전략 패턴 적용
> - 오브젝트를 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만든다.
> - 인터페이스의 메서드를 통해 생성된 인스턴스의 메서드를 호출한다. (Override)   
> 
> 단점 : 컨텍스트가 인터페이스 뿐 아니라 특정 구현 클래스를 알고 있어야 한다.

> DI 적용을 위한 클라이언트 / 컨텍스트 분리
> - Client 가 구체적인 전략 하나를 선택하고 오브젝트로 만들어서 Context 에 전달하게 한다.
> - Context 는 전달받는 Strategy 구현 클래스의 오브젝트를 사용한다.
> 
> 아직 클라이언트와 컨텍스트를 분리하진 않았지만 위 두개의 단점을 모두 없앤 방법

### 템플릿 & 콜백
> 클라이언트에서 템플릿 안에서 실행될 콜백을 전달하고 템플릿을 호출한다.    
> 템플릿은 작업 흐름에 따라 콜백을 호출하고 작업을 마무리한다.
>
>메서드로 추출 후 내부에서 익명 클래스를 생성하여 파라미터로 넘긴다.   
>익명 클래스의 메서드에 추출한 메서드의 파리미터로 넘긴 값이 들어간다.  

> try / catch / finally 블록은 템플릿/콜백 패턴의 후보다.

1. 중복되는 부분을 추출하여 템플릿 메서드를 만든다.
2. 템플릿에서 호출할 콜백 인터페이스를 만든다.
3. 각 메서드는 콜백 메서드를 재정의하여 템플릿 메서드에 파라미터로 넘긴다.
4. 재정의 된 콜백 메서드가 각각 다른 동작을 수행한다.
5. 람다식을 이용하면 콜백 인터페이스 없이 동작하는 콜백 메서드를 생성할 수 있다.